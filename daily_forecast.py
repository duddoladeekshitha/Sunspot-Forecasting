# -*- coding: utf-8 -*-
"""Daily_forecast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TeAUFJXeifQYBG6gwkx70ynJz_9Hunkt
"""

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, r2_score

# Load dataset
data = pd.read_csv('SN_d_tot_V2.0.csv', sep=';', header=None)

#Assigning column names
data.columns = [
    'Year', 'Month', 'Day', 'Fraction_Year', 'Sunspot_Number',
    'Standard_Deviation', 'Observations', 'Indicator'
]
data.columns

# Combining Year, Month, and Day into a single 'Date' column
data['Date'] = pd.to_datetime(data[['Year', 'Month', 'Day']])

data = data.sort_values('Date')

data

# Handle missing values (-1 indicates missing data)
data['Sunspot_Number'] = data['Sunspot_Number'].replace(-1, None)
data = data.dropna(subset=['Sunspot_Number'])
data

# Prepare data for Prophet
prophet_data = data[['Date', 'Sunspot_Number']].rename(columns={'Date': 'ds', 'Sunspot_Number': 'y'})
prophet_data

# Detect time unit (daily, monthly, yearly)
time_diffs = data['Date'].diff().dt.days.dropna()
mode_diff = time_diffs.mode()[0]
if mode_diff == 1:
    time_unit = 'daily'
    prediction_horizons = [100, 200, 365]
    freq = 'D'
elif mode_diff <= 31:
    time_unit = 'monthly'
    prediction_horizons = [1, 6, 9]
    freq = 'MS'
else:
    time_unit = 'yearly'
    prediction_horizons = [1, 10, 20]
    freq = 'YS'

print(f"Detected time unit: {time_unit}")

# Train-test split: Use all but the last year for training, last year for testing
train = prophet_data.iloc[:-365]
test = prophet_data.iloc[-365:]
train

test

# Define custom growth, seasonality, and changepoint options
growth_options = ['linear', 'logistic']
seasonality_options = [
    {'name': 'yearly', 'period': 365.25, 'fourier_order': 10},
    {'name': 'custom_monthly', 'period': 30.5, 'fourier_order': 5},
]
changepoint_options = [
    {'n_changepoints': 25, 'changepoint_prior_scale': 0.05},
    {'n_changepoints': 50, 'changepoint_prior_scale': 0.1},
]

print(f"Growth options: {growth_options}")
print(f"Seasonality options: {seasonality_options}")
print(f"Changepoint options: {changepoint_options}")

# Metrics storage
results = []
results_df = pd.DataFrame(columns=['Growth', 'Seasonality', 'Changepoints', 'Horizon', 'MAE', 'MAPE', 'R2'])
results_df

# Define the capacity for logistic growth
max_y = train['y'].max()
cap_value = max_y * 1.2

# Add the 'cap' column to training, test, and full data
cap_value = train['y'].max() * 1.2
train.loc[:, 'cap'] = cap_value
test.loc[:, 'cap'] = cap_value
prophet_data.loc[:, 'cap'] = cap_value

# Tune and evaluate the model
best_model = None
best_metrics = {'mae': float('inf')}
for growth in growth_options:
    for seasonality in seasonality_options:
        for changepoint in changepoint_options:
 # Initialize Prophet model
            model = Prophet(
                growth='logistic',
                n_changepoints=changepoint['n_changepoints'],
                changepoint_prior_scale=changepoint['changepoint_prior_scale']
            )
            model.add_seasonality(
                name=seasonality['name'],
                period=seasonality['period'],
                fourier_order=seasonality['fourier_order']
            )
 # Fit the model
model.fit(train)

# Train and predict for each period
forecasts = {}
for horizon in prediction_horizons:
    print(f"\nTraining for prediction of {horizon} {time_unit}...")

# Initializing Prophet
model = Prophet()
model.fit(prophet_data)

# Create future dataframe based on time unit
future = model.make_future_dataframe(periods=horizon, freq=freq)
forecast = model.predict(future)

# Extract true values and predicted values
y_true = test['y'].values
y_pred = forecast.loc[forecast['ds'].isin(test['ds']), 'yhat'].values

# Calculate evaluation metrics
mae = mean_absolute_error(y_true, y_pred)
mape = mean_absolute_percentage_error(y_true, y_pred)
r2 = r2_score(y_true, y_pred)

# Tabular representation of metrics using tabulate
metrics = [
    ['Mean Absolute Error (MAE)', mae],
    ['Mean Absolute Percentage Error (MAPE)', mape],
    ['RÂ² Score', r2]
]

print("Evaluation Metrics:")
print(tabulate(metrics, headers=['Metric', 'Value'], tablefmt='grid'))

# Visualizations
# Forecast plot
model.plot(forecast)
plt.title("Sunspot Forecast with FBProphet")
plt.xlabel("Date")
plt.ylabel("Sunspot Number")
plt.show()

# Forecast components
model.plot_components(forecast)
plt.show()

# Residual distribution
residuals = y_true - y_pred
plt.figure(figsize=(10, 6))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title("Residual Distribution")
plt.xlabel("Residuals")
plt.ylabel("Frequency")
plt.show()

# Actual vs Predicted plot
plt.figure(figsize=(12, 6))
plt.plot(test['ds'], y_true, label='Actual Values', color='blue', linewidth=2)
plt.plot(test['ds'], y_pred, label='Predicted Values', color='orange', linestyle='--', linewidth=2)
plt.title("Actual vs Predicted Sunspot Numbers")
plt.xlabel("Date")
plt.ylabel("Sunspot Number")
plt.legend()
plt.grid()
plt.show()

# Error over time
residuals = y_true - y_pred
plt.figure(figsize=(12, 6))
plt.plot(test['ds'], residuals, label='Residuals', color='red', linewidth=2)
plt.axhline(0, color='black', linestyle='--', linewidth=1)
plt.title("Residuals Over Time")
plt.xlabel("Date")
plt.ylabel("Residuals (Actual - Predicted)")
plt.legend()
plt.grid()
plt.show()

# Rolling mean of residuals
rolling_residuals = pd.Series(residuals).rolling(window=30).mean()

plt.figure(figsize=(12, 6))
plt.plot(test['ds'], rolling_residuals, label='30-Day Rolling Mean of Residuals', color='purple', linewidth=2)
plt.axhline(0, color='black', linestyle='--', linewidth=1)
plt.title("30-Day Rolling Mean of Residuals")
plt.xlabel("Date")
plt.ylabel("Mean Residuals")
plt.legend()
plt.grid()
plt.show()